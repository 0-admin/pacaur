#!/bin/bash

#
# pacaur: a fast workflow AUR wrapper using cower as backend
#

name="pacaur"
version="2.5.5"


#
# Config
#

# tmpdir
tmpDir="${TMPDIR:-/tmp}/${name}tmp-$USER"
[[ -d "$tmpDir" ]] && rm -rf "$tmpDir" &>/dev/null || sudo rm -rf "$tmpDir"
mkdir -p "$tmpDir"

# locale
export LANG=C

# general options
buildDir="$tmpDir"              # build directory
editor=${EDITOR:-vi}            # PKGBUILD editor
color=false                     # enable color
clean=true                      # cleanup after install
fallback=true                   # pacman fallback

# advanced options
editpkgbuild=true               # edit PKGBUILD
editinstall=true                # edit install script
cleandevel=true                 # cleanup devel after install
carchmagic=false                # CARCH compatibility

# source config
if [[ -n "${XDG_CONFIG_DIRS}" ]]; then
    xdg_config=($(echo "${XDG_CONFIG_DIRS}" | awk -F ":" '{for (i=1; i<=NF; i++) print $i}' ))
    for i in ${xdg_config[@]}; do
        [[ -d "$i" ]] && export XDG_CONFIG_DIRS=$i && break
    done
fi
configDir="${XDG_CONFIG_DIRS:-/etc/xdg}/${name}"
userconfigDir="${XDG_CONFIG_HOME:-${HOME}/.config}/${name}"
source "$configDir/${name}.conf"
[[ -r "$userconfigDir/config" ]] && source "$userconfigDir/config"

#
# Color
#

if $color; then
    pacmanBin='pacman-color'
    cower='cower --color=always'
    reset="\e[0m"
    colorR="\e[1;31m"
    colorG="\e[1;32m"
    colorY="\e[1;33m"
    colorB="\e[1;34m"
    colorM="\e[1;35m"
    colorC="\e[1;36m"
    colorW="\e[1;39m"
else
    pacmanBin='pacman'
    cower='cower'
fi


#
# Functions
#

SearchAur() {
    [[ $quiet ]] && $cower -sq --color=never $@ || $cower -s $@
}

InfoAur() {
    [[ $count -eq 1 ]] && $cower -i $@ || $cower -ii $@
}

DownloadAur() {
    [[ $recursive ]] && d="-dd" || d="-d"
    [[ $operation = download ]] && deps+=($($cower $d ${coweropts[@]} $@ -t $buildDir | tee 1>&2 >(awk -F " " '{print $2}'| sed -r "s:\x1B\[[0-9;]*[mK]::g")))
    [[ ! $operation = download ]] && deps+=($($cower $d ${coweropts[@]} $@ -t $buildDir 2>"$tmpDir/repodeps" | awk -F " " '{print $2}'| sed -r "s:\x1B\[[0-9;]*[mK]::g"))
    [[ -e "$tmpDir/repodeps" ]] && grep 'no results found for' "$tmpDir/repodeps"

    timeout ${deps[@]}
}

DownloadPkgs() {
    # set architecture variables
    source /etc/makepkg.conf

    if [[ $carchmagic = false ]]; then
        recursive=true && DownloadAur ${aurpkgs[@]}
        # check for CARCH 32/64bits bash magic
        for i in "${deps[@]}"; do
            [[ -n $(grep 'CARCH' "$buildDir/$i/PKGBUILD") ]] && error "${colorW}$i${reset} requires \$CARCH bash magic compatibility to be enabled.\nCheck configuration in $configDir/${name}.conf or use --carch option."
        done
        # check binary depends pkgs
        [[ -e "$tmpDir/repodeps" ]] && repodeps=($(cat "$tmpDir/repodeps" | grep -v 'no results found for' | awk -F " " '{print $2}' | sed -r "s:\x1B\[[0-9;]*[mK]::g"))
    else
        allaurdeps+=("${aurpkgs[@]}")
        FindPkgsDeps ${aurpkgs[@]}
        deps=("${allaurdeps[@]}")
        # reduce root binary deps
        repodeps=($(echo "${repodeps[@]}" | sed 's/ /\n/g' | sort -u))
    fi

    # return AUR deps pkgs only
    aurdepspkgs=(${deps[@]:${#aurpkgs[@]}:${#deps[@]}})

    # show binary deps
    if [[ -n "${repodeps[@]}" ]]; then
        for i in "${repodeps[@]}"; do
            allrepopkgs+=($(pactree -su "$i"))
        done
        repodepspkgs=($($pacmanBin -T "${allrepopkgs[@]}"))
        [[ -n "${repodepspkgs[@]}" ]] && expac -S -1 "${colorY}::${reset} ${colorW}%n${reset} is available in ${colorM}%r${reset}" "${repodepspkgs[@]}" | sort -u
    fi
}

FindPkgsDeps() {
    [[ -z "${depspkgsaur[@]}" ]] && depspkgsaur=(${aurpkgs[@]})

    DownloadAur ${depspkgsaur[@]}
    # source pkgs
    for i in "${deps[@]}"; do
        . "$buildDir/$i/PKGBUILD"
        sourcedpkgs+=($(echo -e "${depends[*]}\n${makedepends[*]}"))
    done
    # remove installed deps
    depspkgs=($($pacmanBin -T "${sourcedpkgs[@]}"))
    # split binary and AUR depends pkgs
    [[ -e "$tmpDir/aurdeps" ]] && rm "$tmpDir/aurdeps"
    [[ -n "${depspkgs[@]}" ]] && depspkgsrepo=($(expac -S -1 -v %n ${depspkgs[@]} 2>"$tmpDir/aurdeps")) && repodeps+=(${depspkgsrepo[@]})
    [[ -e "$tmpDir/aurdeps" ]] && depspkgsaur=($(cat "$tmpDir/aurdeps" | grep 'error:' | awk -F "\`" '{print $2}' | awk -F "'" '{print $1}')) || unset depspkgsaur
    unset deps sourcedpkgs depends makedepends depspkgs

    if [[ -n "${depspkgsaur[@]}" ]]; then
        # remove AUR package versioning
        j=0
        for i in "${depspkgsaur[@]}"; do
            depspkgsaur[$j]=$(echo "$i" | awk -F "<" '{print $1}' | awk -F ">" '{print $1}' | awk -F "=" '{print $1}')
            ((j++))
        done
        for i in "${depspkgsaur[@]}"; do
            [[ " ${allaurdeps[@]} " =~ " $i " ]] && continue || allaurdeps+=("$i")
        done
        FindPkgsDeps ${depspkgsaur[@]}
    fi
}

UpgradeAur() {
    # ignore check
    GetIgnoredPkgs

    info "${colorW}Starting AUR upgrade...${reset}"

    aurpkgs+=($($cower -u ${pkgs[@]} ${ignoreopts[@]} | tee 1>&2 >(awk -F " " '{print $2}'| sed -r "s:\x1B\[[0-9;]*[mK]::g")))

    # add devel packages
    if [[ $devel ]]; then
        allaurpkgs=($($pacmanBin -Qmq))
        Qversion=($(expac -Q %v "${allaurpkgs[@]}"))

        for i in "${allaurpkgs[@]}"; do
            DownloadPkgbuild $i &
            paraexec
        done
        wait
        for ((i=0; i<${#allaurpkgs[@]}; i++)); do
            unset _darcstrunk _cvsroot _gitroot _svntrunk _bzrtrunk _hgroot
            . "$tmpDir/${allaurpkgs[$i]}.PKGBUILD"
            if [[ ${_darcstrunk} || ${_cvsroot} || ${_gitroot} || ${_svntrunk} || ${_bzrtrunk} || ${_hgroot} ]]; then
                if [[ " ${ignoredpkgs[@]} " =~ " ${allaurpkgs[$i]} " ]]; then
                    warn "${colorW}${allaurpkgs[$i]} ${colorY}${Qversion[$i]}${reset}: ignoring package upgrade"
                    continue
                else
                    info "${colorW}${allaurpkgs[$i]} ${colorY}${Qversion[$i]} ${reset}"
                    aurpkgs+=("${allaurpkgs[$i]}")
                fi
            fi
        done
    fi

    nothingtodo ${aurpkgs[@]}
    timeout ${aurpkgs[@]}
}

Prompt() {
    [[ $option ]] && echo -e "\n${colorY}AUR Targets (${#deps[@]}):${reset} ${deps[@]}"
    [[ ! $option ]] && echo "" && info "${colorW}${#deps[@]}${reset} AUR package(s) to build: ${colorW}${deps[@]}${reset}"
    echo ""

    if [[ ! $noconfirm ]]; then
        [[ $installpkg ]] && action="installation" || action="download"
        if ! proceedY "Proceed with $action?"; then
            CleanUp ${deps[@]} &>/dev/null
            exit
        fi
    fi

    EditPkgs ${deps[@]}
}

EditPkgs() {
    [[ $noedit ]] && return
    [[ $operation ]] && [[ ! $edit ]] && return
    for i in "$@"; do
       # edit pkgbuild
       if [[ ! $editpkgbuild = false ]]; then
            if [[ $option ]]; then
                if proceedY "${colorB}::${reset} Edit ${colorW}$i${reset} PKGBUILD?"; then
                    [[ -e "$buildDir/$i/PKGBUILD" ]] && $editor "$buildDir/$i/PKGBUILD" && success "${colorW}$i${reset} PKGBUILD edited" || error "Could not open ${colorW}$i${reset} PKGBUILD"
                fi
            else
                [[ -e "$buildDir/$i/PKGBUILD" ]] && $editor "$buildDir/$i/PKGBUILD" && success "${colorW}$i${reset} PKGBUILD edited" || error "Could not open ${colorW}$i${reset} PKGBUILD"
            fi
        fi
        # edit install script
        if [[ ! $editinstall = false ]]; then
            unset install
            [[ -e "$buildDir/$i/PKGBUILD" ]] && source "$buildDir/$i/PKGBUILD"
            if [[ $install ]]; then
                if [[ $option ]]; then
                    if proceedY "${colorB}::${reset} View ${colorW}$i${reset} .install script?"; then
                        [[ -e "$buildDir/$i/$install" ]] && $editor "$buildDir/$i/$install" && success "${colorW}$i${reset} install script viewed" || error "Could not open ${colorW}$i${reset} install script"
                    fi
                else
                    [[ -e "$buildDir/$i/$install" ]] && $editor "$buildDir/$i/$install" && success "${colorW}$i${reset} install script viewed" || error "Could not open ${colorW}$i${reset} install script"
                fi
            fi
        fi
    done
}

MakePkgs() {
    # initialize sudo
    runasroot

    # reverse deps order
    deps=($(echo "${deps[@]}" | awk -F "\n" '{print}' | awk -F " " '{for (i=NF;i>=1;i--) print $i}'))

    # makepkg options
    [[ $color != true ]] && makeopts+=("--nocolor")
    export PACMAN=$pacmanBin

    if [[ $installpkg ]]; then
        for i in "${deps[@]}"; do
            # check package cache
            [[ $PKGDEST && ! $rebuild ]] && GetAurVersion $i && FindCachedPkg "$i-$Aversion"
            if [[ $cachedpkg ]]; then
                info "Installing ${colorW}$i${reset} cached package..."
                yes | runasroot $pacmanBin -U $cachedpkg ${pacopts[@]}
            else
                # build and install
                if [[ -e "$buildDir/$i/PKGBUILD" ]]; then
                    info "Building ${colorW}$i${reset} package..."
                    cd "$buildDir/$i"
                    yes | makepkg -sfi ${makeopts[@]}
                else
                    error "Could not open ${colorW}$i${reset} PKGBUILD"
                fi
            fi
            # set dep status
            [[ ! $upgrade ]] && ! [[ " ${pkgs[@]} " =~ " $i " ]] && runasroot $pacmanBin -D $i --asdeps ${pacopts[@]} &>/dev/null
            [[ " ${pacopts[@]} " =~ " --asdeps " ]] && runasroot $pacmanBin -D $i --asdeps ${pacopts[@]} &>/dev/null
            [[ " ${pacopts[@]} " =~ " --asexplicit " ]] && runasroot $pacmanBin -D $i --asexplicit ${pacopts[@]} &>/dev/null
        done
    else
        # check destination folder
        [[ ! $PKGDEST ]] && [[ $clean = true ]] && error "Please set ${colorW}PKGDEST${reset} variable in /etc/makepkg.conf or disable ${colorW}clean${reset} option."

        for i in "${deps[@]}"; do
            # check package cache
            [[ $PKGDEST && ! $rebuild ]] && GetAurVersion $i && FindCachedPkg "$i-$Aversion"
            if [[ $cachedpkg ]]; then
                info "Package ${colorW}$i${reset} already available in cache"
            else
                # build
                if [[ -e "$buildDir/$i/PKGBUILD" ]]; then
                    info "Building ${colorW}$i${reset} package..."
                    cd "$buildDir/$i"
                    if [[ " ${aurdepspkgs[@]} " =~ " $i " ]]; then
                        # install AUR deps
                        info "Installing ${colorW}$i${reset} dependency..."
                        yes | makepkg -sfi ${makeopts[@]}
                    else
                        # install then remove binary deps
                        yes | makepkg -sfr ${makeopts[@]}
                    fi
                else
                    error "Could not open ${colorW}$i${reset} PKGBUILD"
                fi
                # set dep status
                runasroot $pacmanBin -D $i --asdeps ${pacopts[@]} &>/dev/null
            fi
        done
        # remove AUR deps
        [[ -n "${aurdepspkgs[@]}" ]] && info "Removing installed AUR dependencies..."
        [[ -n "${aurdepspkgs[@]}" ]] && runasroot $pacmanBin -Rsn ${aurdepspkgs[@]} --noconfirm
    fi
}

CleanUp() {
    if [[ $clean = true ]]; then
        if [[ $count -eq 1 ]]; then
            cd "$buildDir"
            for i in "$@"; do
                # hack for cvs protected files
                chmod -R 755 $i &>/dev/null
                rm -r $i &>/dev/null && success "${colorW}$i${reset} cleaned" || warn "Could not clean ${colorW}$i${reset}"
            done
        else
            # skip if devel package
            if [[ $cleandevel = false && $count -ne 2 ]]; then
                for i in "$@"; do
                    cd "$buildDir"
                    unset _darcstrunk _cvsroot _gitroot _svntrunk _bzrtrunk _hgroot
                    . "$i/PKGBUILD"
                    [[ ${_darcstrunk} || ${_cvsroot} || ${_gitroot} || ${_svntrunk} || ${_bzrtrunk} || ${_hgroot} ]] && success "${colorW}$i${reset} cleaning skipped" && continue
                    # hack for cvs protected files
                    chmod -R 755 $i &>/dev/null
                    rm -r $i &>/dev/null && success "${colorW}$i${reset} cleaned" || warn "Could not clean ${colorW}$i${reset}"
                done
            else
                # hack for cvs protected files
                chmod -R 755 $buildDir/* &>/dev/null
                rm -r $buildDir/* &>/dev/null && success "Build directory cleaned" || warn "Build directory already cleaned"
            fi
        fi
    fi
}

CheckAur() {
    [[ $quiet ]] && $cower -uq --color=never $@ || $cower -u $@
    # override unconventional cower exit codes
    [[ -z "${pkgs[@]}" ]] && return 0 || expac -Q '%n' ${pkgs[@]} &>/dev/null
}

CheckRepo() {
    outofdate=($($pacmanBin -Quq $@))
    if [[ -n "${outofdate[@]}" ]]; then
        Qversion=($(expac -Q %v "${outofdate[@]}"))
        Sversion=($(expac -S -1 %v "${outofdate[@]}"))
        for ((i=0; i<${#outofdate[@]}; i++)); do
            Qgroup[$i]=$(expac -Q -l " " '%G' "${outofdate[$i]}")
        done
        local i=0
        for j in "${outofdate[@]}"; do
            [[ -n "${Qgroup[$i]}" ]] && Qgroup[$i]="(${Qgroup[$i]})"
            [[ ! $quiet ]] && info "${colorW}$j ${colorR}${Qversion[$i]} ${reset}-> ${colorG}${Sversion[$i]}${reset} ${colorB}${Qgroup[$i]}${reset}" || echo "$j"
            ((i++))
        done
    fi
}

CleanCache() {
    # set cache variables
    source /etc/makepkg.conf

    if [[ $PKGDEST && $PKGDEST != '/var/cache/pacman/pkg/' ]]; then
        [[ ! $aur ]] && echo ""
        echo -e "${colorW}AUR cache directory:${reset} $PKGDEST"
        if [[ $count -eq 1 ]]; then
            echo -e "${colorW}Packages to keep:${reset}\n  All locally installed packages"
            if ! proceedY "Do you want to remove all other packages from AUR cache?"; then
                exit
            fi

            echo "removing old packages from cache..."
            for i in $(ls $PKGDEST | sed "s#\(.*\)-.*#\1#g" ); do
                pkgname=$(echo "$i" | sed "s#\(.*\)-.*-.*#\1#g")
                [[ $i != $(expac -Q '%n-%v' "$pkgname") ]] && rm $PKGDEST/$i-*
            done
        else
            if ! proceedN "Do you want to remove ALL files from AUR cache?"; then
                echo "removing all files from AUR cache..."
                rm $PKGDEST/* &>/dev/null
            fi
        fi
    fi
}

ConflictChecks() {
    if [[ ! $noconfirm ]]; then
        local k=0
        for i in "${deps[@]}"; do
            unset conflicts
            [[ -e "$buildDir/$i/PKGBUILD" ]] && [[ -n $(grep 'conflicts=(' "$buildDir/$i/PKGBUILD") ]] && . "$buildDir/$i/PKGBUILD"
            [[ -z "${conflicts[@]}" ]] && conflicts=($(expac -Q %n "$i")) || [[ -n "${conflicts[@]}" ]] && conflicts=($(expac -Q %n "${conflicts[@]}"))
            # return when no conflict
            [[ " ${conflicts[@]} " =~ " $i " ]] && continue || conflictspkgs=("${conflicts[@]}")

            for j in "${conflictspkgs[@]}"; do
                if [[ $j = $i ]]; then
                    continue
                else
                    if ! proceedN "${colorB}::${reset} ${colorW}$i and $j are in conflict. Remove $j?${reset}"; then
                        break
                    else
                        [[ " ${pkgs[@]} " =~ " $i " ]] && unset deps[$k] || error "failed to prepare transaction (conflicting dependencies)"
                    fi
                fi
            done
            ((k++))
        done
    fi

    nothingtodo ${deps[@]}
}

ReinstallChecks() {
    exist=($(expac -Q %n "${deps[@]}"))
    Qversion=($(expac -Q %v "${deps[@]}"))
    for ((i=0; i<${#exist[@]}; i++)); do
        [[ " ${deps[@]} " =~ " ${exist[$i]} " ]] && GetAurVersion ${exist[$i]} || continue
        [[ $(vercmp "$Aversion" "${Qversion[$i]}") -gt 0 ]] && continue || warn "${exist[$i]}-${Qversion[$i]} is up to date -- reinstalling"
    done
}

OutofdateChecks() {
    for i in "${deps[@]}"; do
        DownloadJson $i &
        paraexec
    done
    wait
    for i in "${deps[@]}"; do
        [[ -n $(grep '"OutOfDate":"1"' "$tmpDir/$i.json") ]] && warn "$i is flagged ${colorR}out of date${reset}"
    done
}

IgnoreChecks() {
    [[ ! $upgrade ]] && GetIgnoredPkgs
    [[ -z "${ignoredpkgs[@]}" ]] && return

    checkaurpkgs=(${aurpkgs[@]})
    unset aurpkgs

    # check targets
    for i in "${checkaurpkgs[@]}"; do
        if [[ " ${ignoredpkgs[@]} " =~ " $i " ]]; then
            if [[ ! $upgrade && ! $noconfirm ]]; then
                if ! proceedY "${colorY}::${reset} $i is in IgnorePkg/IgnoreGroup. Install anyway?"; then
                    continue
                fi
            else
                warn "${colorW}$i${reset}: ignoring package upgrade"
                continue
            fi
        fi
        aurpkgs+=("$i")
    done

    nothingtodo ${aurpkgs[@]}
}

IgnoreDepsChecks() {
    unset deps

    # add checked targets
    deps+=("${aurpkgs[@]}")

    # check dependencies
    for i in "${repodepspkgs[@]}"; do
        if [[ " ${ignoredpkgs[@]} " =~ " $i " ]]; then
            warn "${colorW}$i${reset}: ignoring package upgrade"
            CleanUp ${aurpkgs[@]} &>/dev/null
            CleanUp ${aurdepspkgs[@]} &>/dev/null
            error "Unresolved dependency '${colorW}$i${reset}'"
        fi
    done
    for i in "${aurdepspkgs[@]}"; do
        if [[ " ${ignoredpkgs[@]} " =~ " $i " ]]; then
            if [[ ! $noconfirm ]]; then
                if ! proceedY "${colorY}::${reset} $i dependency is in IgnorePkg/IgnoreGroup. Install anyway?"; then
                    CleanUp ${aurpkgs[@]} &>/dev/null
                    CleanUp ${aurdepspkgs[@]} &>/dev/null
                    error "Unresolved dependency '${colorW}$i${reset}'"
                fi
            else
                warn "${colorW}$i${reset}: ignoring package upgrade"
                CleanUp ${aurpkgs[@]} &>/dev/null
                CleanUp ${aurdepspkgs[@]} &>/dev/null
                error "Unresolved dependency '${colorW}$i${reset}'"
            fi
        fi
        deps+=("$i")
    done
}

GetIgnoredPkgs() {
    ignoredpkgs+=($(grep '^ *IgnorePkg' '/etc/pacman.conf' | cut -d '=' -f 2-))
    [[ -e "$HOME/.config/cower/config" ]] && ignoredpkgs+=($(grep '^ *IgnorePkg' "$HOME/.config/cower/config" | cut -d '=' -f 2-))
    ignoredpkgs=(${ignoredpkgs[@]//,/ })
}

GetIgnoredGrps() {
    ignoredgrps+=($(grep '^ *IgnoreGroup' '/etc/pacman.conf' | cut -d '=' -f 2-))
}

GetAurVersion() {
    Apkgver=$(grep '^pkgver' "$buildDir/$@/PKGBUILD" | cut -d '=' -f 2-)
    Apkgrel=$(grep '^pkgrel' "$buildDir/$@/PKGBUILD" | cut -d '=' -f 2-)
    Aversion="$Apkgver-$Apkgrel"
}

FindCachedPkg() {
    cachedpkg="$PKGDEST/$@-${CARCH}${PKGEXT}"
    [[ ! -f "$cachedpkg" ]] && cachedpkg="$PKGDEST/$@-any${PKGEXT}"
    [[ ! -f "$cachedpkg" ]] && cachedpkg=""
}

DownloadPkgbuild() {
    [[ ! -f "$tmpDir/$i.PKGBUILD" ]] && curl -Lfs "https://aur.archlinux.org/packages/$i/PKGBUILD" > "$tmpDir/$i.PKGBUILD" || error "no results found for $i"
}

DownloadJson() {
    [[ ! -f "$tmpDir/$i.json" ]] && curl -Lfs "https://aur.archlinux.org/rpc.php?type=info&arg=$i" > "$tmpDir/$i.json" || error "no results found for $i"
}

Core() {
    IgnoreChecks
    DownloadPkgs ${aurpkgs[@]}
    [[ -n "${ignoredpkgs[@]}" ]] && IgnoreDepsChecks ${deps[@]}
    ConflictChecks ${deps[@]}
    ReinstallChecks ${deps[@]}
    OutofdateChecks ${deps[@]}
    Prompt ${deps[@]}
    MakePkgs ${deps[@]}
    CleanUp ${deps[@]}
}

ClassifyPkgs() {
    if [[ $fallback = true ]]; then
        [[ $repo ]] && repopkgs=(${pkgs[@]})
        [[ $aur ]] && aurpkgs=(${pkgs[@]})
        if [[ ! $repo && ! $aur ]]; then
            GetIgnoredGrps
            for i in "${pkgs[@]}"; do
                [[ " ${ignoredgrps[@]} " =~ " $i " ]] && repopkgs+=("$i") && continue
                [[ -z "$($pacmanBin -S --print $i 2>&1 | grep -v 'error:')" ]] && aurpkgs+=("$i") || repopkgs+=("$i")
            done
        fi
    else
        [[ ! $aur ]] && repopkgs=(${pkgs[@]}) || aurpkgs=(${pkgs[@]})
    fi
}

runasroot() {
    [[ ! $@ ]] && sudo -v || sudo "$@"
}

proceedY() {
    echo -ne "$* [Y/n] "
    read -n 1 yn
    echo ""
    case $yn in
        [Yy]|'') return 0;;
        *) return 1;;
    esac
}

proceedN() {
    echo -ne "$* [y/N] "
    read -n 1 ny
    echo ""
    case $ny in
        [Nn]|'') return 0;;
        *) return 1;;
    esac
}

paraexec() {
    while (( $(jobs | wc -l) >= 10 )); do
        sleep 0.1
        jobs > /dev/null
    done
}

timeout() {
    [[ -z "$(echo "$@" | grep -v 'resolve host name' | grep -v 'no results found for')" ]] && exit 1 || return 0
}

nothingtodo() {
    [[ -z "$@" ]] && echo " there is nothing to do" && exit || return 0
}

error() {
    echo -e "${colorR}::${reset} $1" && exit 1
}

success() {
    echo -e "${colorG}::${reset} $1"
}

warn() {
    echo -e "${colorY}::${reset} $1"
}

info() {
    echo -e "${colorB}::${reset} $1"
}

usage() {
    echo "usage:  ${name} <operation> [options] [package(s)]"
    echo "operations:"
    echo " AUR only"
    echo "   -s, --search    search AUR repository for matching strings"
    echo "   -i, --info      view package information -- pass twice for details"
    echo "   -d, --download  download target(s) -- pass twice to download AUR dependencies"
    echo "   -m, --makepkg   download and make target(s)"
    echo "   -y, --sync      download, make and install target(s)"
    echo "   -k, --check     check for AUR update(s)"
    echo "   -u, --update    update AUR package(s)"
    echo " general"
    echo "   -c, --clean     clean target(s) build files -- pass twice to clean the entire build directory"
    echo "   -v, --version   display version information"
    echo "   -h, --help      display help information"
    echo ""
    echo "options:"
    echo "   -e, --edit      edit target PKGBUILD -- can be combined with the -d, -m, -y, -u flags"
    echo "   -f, --force     overwrite existing files -- can be combined with the -d flag"
    echo "   -q, --quiet     show less information for query and search"
    echo "   --devel         consider AUR development packages upgrade"
    echo "   --ignore        ignore a package upgrade (can be used more than once)"
    echo "   --noconfirm     do not prompt for any confirmation"
    echo "   --noedit        do not prompt to edit files"
    echo "   --rebuild       always rebuild package"
    echo ""
    echo "pacman options:"
    echo " can be used with the -S, -Ss, -Si, -Sii, -Sw, -Su, -Qu, -Sc, -Scc operations"
    echo "   -a, --aur       only search or install packages from the AUR"
    echo "   -r, --repo      only search or install packages from the repositories"
    echo ""
    exit
}

version() {
    echo "$name $version"
}


#
# Argument parsing
#

[[ $1 ]] || usage
pkgs=()
count=0
while [[ $1 ]]; do
    case "$1" in
        '-s'|'--search') operation=search;;
        '-i'|'--info') operation=info; ((count++));;
        '-d'|'--download') operation=download; ((count++));;
        '-m'|'--makepkg') operation=makepkg; coweropts+=("-f");;
        '-y'|'--sync') operation=makepkg; installpkg=true; coweropts+=("-f");;
        '-k'|'--check') operation=check;;
        '-u'|'--update') operation=makepkg; upgrade=true; installpkg=true; coweropts+=("-f");;
        '-f') coweropts+=("-f");;
        '--force') coweropts+=("-f"); pacopts+=("--force");;
        '-e'|'--edit') edit=true; editpkg=true;;
        '-c'|'--clean') clean=true; cleanpkg=true; ((count++));;
        '-q'|'--quiet') quiet=true;;
        # shortcuts
        '-sq') operation=search; quiet=true;;
        '-ii') operation=info; count=2;;
        '-dd') operation=download; count=2;;
        '-df') operation=download; ((count++)); coweropts+=("-f");;
        '-de') operation=download; ((count++)); edit=true;;
        '-def'|'-dfe') operation=download; ((count++)); edit=true; coweropts+=("-f");;
        '-ddf') operation=download; count=2; coweropts+=("-f");;
        '-dde') operation=download; count=2; edit=true;;
        '-ddef'|'-ddfe') operation=download; count=2; edit=true; coweropts+=("-f");;
        '-me') operation=makepkg; edit=true; coweropts+=("-f");;
        '-ye') operation=makepkg; edit=true; installpkg=true; coweropts+=("-f");;
        '-kq') operation=check; quiet=true;;
        '-ue') operation=makepkg; upgrade=true; edit=true; installpkg=true; coweropts+=("-f");;
        '-cc') clean=true; cleanpkg=true; count=2;;
        # pacman
        '-S') option=sync; installpkg=true; coweropts+=("-f");;
        '-Ss') option=search;;
        '-Si') option=info; ((count++));;
        '-Sii') option=info; count=2;;
        '-Sw') option=sync; coweropts+=("-f");;
        '-Sy') option=sync; installpkg=true; refresh=true; coweropts+=("-f");;
        '-Qu') option=upgrades;;
        '-Sc') option=cleancache; ((count++)); pacmanarg="$1";;
        '-Scc') option=cleancache; count=2; pacmanarg="$1";;
        '-r'|'--repo') repo='1';;
        '-a'|'--aur') aur='1';;
        # pacman shortcuts
        '-Sa') option=sync; installpkg=true; coweropts+=("-f"); aur='1';;
        '-Sr') option=sync; installpkg=true; coweropts+=("-f"); repo='1';;
        '-Ssa') option=search; aur='1';;
        '-Ssr') option=search; repo='1';;
        '-Ssq') option=search; quiet=true;;
        '-Ssqa'|'-Ssaq') option=search; quiet=true; aur='1';;
        '-Ssqr'|'-Ssrq') option=search; quiet=true; repo='1';;
        '-Sia') option=info; ((count++)); aur='1';;
        '-Sir') option=info; ((count++)); repo='1';;
        '-Siia') option=info; count=2; aur='1';;
        '-Siir') option=info; count=2; repo='1';;
        '-Swa') option=sync; coweropts+=("-f"); aur='1';;
        '-Swr') option=sync; coweropts+=("-f"); repo='1';;
        '-Sya') option=sync; installpkg=true; refresh=true; coweropts+=("-f"); aur='1';;
        '-Syr') option=sync; installpkg=true; refresh=true; coweropts+=("-f"); repo='1';;
        '-Qua') option=upgrades; aur='1';;
        '-Qur') option=upgrades; repo='1';;
        '-Quq') option=upgrades; quiet=true;;
        '-Quqa') option=upgrades; quiet=true; aur='1';;
        '-Quqr') option=upgrades; quiet=true; repo='1';;
        -S*u*w*a|-S*w*u*a) option=sysupgrade; upgrade=true; pacmanarg="$1"; coweropts+=("-f"); aur='1';;
        -S*u*w*r|-S*w*u*r) option=sysupgrade; upgrade=true; pacmanarg="$1"; coweropts+=("-f"); repo='1';;
        -S*u*w*|-S*w*u*) option=sysupgrade; upgrade=true; pacmanarg="$1"; coweropts+=("-f");;
        -S*u*a) option=sysupgrade; upgrade=true; installpkg=true; pacmanarg="$1"; coweropts+=("-f"); aur='1';;
        -S*u*r) option=sysupgrade; upgrade=true; installpkg=true; pacmanarg="$1"; coweropts+=("-f"); repo='1';;
        -S*u*) option=sysupgrade; upgrade=true; installpkg=true; pacmanarg="$1"; coweropts+=("-f");;
        -Syw|-Swy) option=sync; refresh=true; coweropts+=("-f");;
        -Sywa|-Swya) option=sync; refresh=true; coweropts+=("-f"); aur='1';;
        -Sywr|-Swyr) option=sync; refresh=true; coweropts+=("-f"); repo='1';;
        '-Sca') option=cleancache; ((count++)); pacmanarg="$1"; aur='1';;
        '-Scr') option=cleancache; ((count++)); pacmanarg="$1"; repo='1';;
        '-Scca') option=cleancache; count=2; pacmanarg="$1"; aur='1';;
        '-Sccr') option=cleancache; count=2; pacmanarg="$1"; repo='1';;
        # others
        '--devel') devel=true;;
        '--asroot') makeopts+=("--asroot");;
        '--carch') carchmagic=true;;
        '--ignore') ignoredpkgs+=("$2"); ignoreopts+=("--ignore" "$2"); shift;;
        '--noconfirm') noconfirm=true; pacopts+=("--noconfirm");;
        '--noedit') noedit=true;;
        '--rebuild') rebuild=true;;
        -D* | '--database') runasroot $pacmanBin $@; exit;;
        -Q* | '--query') $pacmanBin $@; exit;;
        -R* | '--remove') runasroot $pacmanBin $@; exit;;
        -S* | '--sync') runasroot $pacmanBin $@; exit;;
        -T* | '--deptest') runasroot $pacmanBin $@; exit;;
        -U* | '--upgrade') runasroot $pacmanBin $@; exit;;
        '-h'|'--help') usage; exit;;
        '-v'|'--version') version; exit;;
        --*) pacopts+=("$1");;
        -*) echo "$name: invalid option -- '$1'"; exit 1;;
        *) pkgs+=("$1");;
    esac
    shift
done


#
# Main
#

# sanity check
[[ ! $editor ]] && [[ ! -f /usr/bin/vi ]] && error "The ${colorW}editor${reset} variable is not set.\nCheck configuration in $configDir/${name}.conf"
[[ ! -d $buildDir ]] && error "Build directory does not exist!\nCheck configuration in $configDir/${name}.conf"
[[ ! -f /usr/bin/$pacmanBin ]] && error "The binary ${colorW}$pacmanBin${reset} is not installed.\nCheck configuration in $configDir/${name}.conf"
[[ ! $operation && ! $option && ! $cleanpkg && ! $editpkg ]] && error "no operation specified (use -h for help)"
[[ $option = sync || $option = info || $option = search ]] && [[ ! $refresh ]] && [[ ! $pkgs ]] && error "no targets specified (use -h for help)"
[[ $repo && $aur ]] && error "target not found"

# search (-s) handling
if [[ $operation = search ]]; then
    SearchAur ${pkgs[@]}
    exit
fi

# info (-i) handling
if [[ $operation = info ]]; then
    InfoAur ${pkgs[@]}
    exit
fi

# download (-d) handling
if [[ $operation = download ]]; then
    [[ $count -eq 1 ]] && DownloadAur ${pkgs[@]}
    [[ $count -ne 1 ]] && recursive=true && DownloadAur ${pkgs[@]}
    EditPkgs ${deps[@]}
    exit
fi

# makepkg (-m) handling
# sync (-y) handling
# update (-u) handling
if [[ $operation = makepkg ]]; then
    # selective upgrade compatibility
    [[ $upgrade ]] && UpgradeAur || aurpkgs=(${pkgs[@]})
    Core ${aurpkgs[@]}
    exit
fi

# check (-k) handling
if [[ $operation = check ]]; then
    CheckAur ${pkgs[@]}
    exit
fi

# pacman search (-Ss) handling
if [[ $option = search ]]; then
    [[ ! $aur ]] && [[ ! $quiet ]] && $pacmanBin -Ss ${pkgs[@]}
    [[ ! $aur ]] && [[ $quiet ]] && $pacmanBin -Ssq ${pkgs[@]}
    [[ ! $repo ]] && [[ $fallback = true || $aur ]] && SearchAur ${pkgs[@]}
    exit
fi

# pacman sync (-S) handling
# pacman downloadonly (-Sw) handling
# pacman refresh (-Sy) handling
if [[ $option = sync ]]; then
    [[ ! ${pkgs[@]} ]] && [[ $refresh ]] && runasroot $pacmanBin -Sy ${pacopts[@]} ${ignoreopts[@]} || ClassifyPkgs ${pkgs[@]}
    if [[ -n "${repopkgs[@]}" ]]; then
        if [[ $refresh ]]; then
            [[ $installpkg ]] && runasroot $pacmanBin -Sy ${pacopts[@]} ${ignoreopts[@]} ${repopkgs[@]}
            [[ ! $installpkg ]] && runasroot $pacmanBin -Syw ${pacopts[@]} ${ignoreopts[@]} ${repopkgs[@]}
        else
            [[ $installpkg ]] && runasroot $pacmanBin -S ${pacopts[@]} ${ignoreopts[@]} ${repopkgs[@]}
            [[ ! $installpkg ]] && runasroot $pacmanBin -Sw ${pacopts[@]} ${ignoreopts[@]} ${repopkgs[@]}
        fi
    fi
    if [[ -n "${aurpkgs[@]}" ]]; then
        [[ $refresh ]] && [[ ! ${repopkgs[@]} ]] && runasroot $pacmanBin -Sy ${pacopts[@]} ${ignoreopts[@]}
        [[ $fallback = true && ! $aur ]] && warn "Package(s) ${colorW}${aurpkgs[@]}${reset} not found in repositories, trying ${colorM}AUR${reset}..."
        Core ${aurpkgs[@]}
    fi
    exit
fi

# pacman info (-Si) handling
if [[ $option = info ]]; then
    ClassifyPkgs ${pkgs[@]}
    if [[ -n "${repopkgs[@]}" ]]; then
        [[ $count -eq 1 ]] && $pacmanBin -Si ${repopkgs[@]}
        [[ $count -ne 1 ]] && $pacmanBin -Sii ${repopkgs[@]}
    fi
    if [[ -n "${aurpkgs[@]}" ]]; then
        [[ $fallback = true && ! $aur ]] && warn "Package(s) ${colorW}${aurpkgs[@]}${reset} not found in repositories, trying ${colorM}AUR${reset}..."
        InfoAur ${aurpkgs[@]}
    fi
    exit
fi

# pacman sysupgrade (-Su) handling
if [[ $option = sysupgrade ]]; then
    ClassifyPkgs ${pkgs[@]} && unset pkgs
    [[ -z "$(echo $pacmanarg | grep -v "r$")" ]] && pacmanarg=${pacmanarg%?}
    [[ ! $aur ]] && runasroot $pacmanBin $pacmanarg ${pacopts[@]} ${ignoreopts[@]} ${repopkgs[@]}
    [[ -n "${aurpkgs[@]}" ]] && [[ $fallback = true && ! $aur ]] && warn "Package(s) ${colorW}${aurpkgs[@]}${reset} not found in repositories, trying ${colorM}AUR${reset}..."
    [[ ! $repo ]] && [[ $fallback = true || $aur ]] && UpgradeAur && Core ${aurpkgs[@]}
    exit
fi

# pacman upgrades (-Qu) handling
if [[ $option = upgrades ]]; then
    [[ ! $aur ]] && CheckRepo ${pkgs[@]}
    [[ ! $repo ]] && [[ $fallback = true || $aur ]] && CheckAur ${pkgs[@]}
    exit
fi

# pacman clean (-Sc) handling
if [[ $option = cleancache ]]; then
    [[ -z "$(echo $pacmanarg | grep -v "r$")" ]] && pacmanarg=${pacmanarg%?}
    [[ ! $aur ]] && runasroot $pacmanBin $pacmanarg
    [[ ! $repo ]] && [[ $fallback = true || $aur ]] && CleanCache ${pkgs[@]}
    exit
fi

# edit (-e) handling
if [[ $editpkg && ! $noedit ]]; then
    EditPkgs ${pkgs[@]}
    exit
fi

# clean (-c) handling
if [[ $cleanpkg ]]; then
    CleanUp ${pkgs[@]}
    exit
fi

# vim:set ts=4 sw=2 et:
